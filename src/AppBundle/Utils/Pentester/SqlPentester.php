<?php
/**
 * File SqlPentester.php
 *
 * PHP Version 5.6
 *
 * @category  Class
 * @package   Zerowing
 * @author    mrgn <xyz@example.com>
 * @copyright 2016 mrgn
 * @license   MIT http://choosealicense.com/licenses/mit/
 * @link      http://lorem.ovh
 */

namespace AppBundle\Utils\Pentester;

use AppBundle\Entity\SqlError;
use AppBundle\Repository\SqlErrorRepository;
use AppBundle\Utils\Reporter\Reporter;
use AppBundle\Utils\Target\SqlTarget;
use AppBundle\Utils\Target\TargetInterface;
use Doctrine\ORM\EntityManager;
use Guzzle\Http\Message\Request;
use Guzzle\Http\Message\RequestInterface;
use Misd\GuzzleBundle\MisdGuzzleBundle;

/**
 * Class SqlPentester
 * @category  Class
 * @package AppBundle\Utils\Pentester
 * @author    mrgn <xyz@example.com>
 * @copyright 2016 mrgn
 * @license   MIT http://choosealicense.com/licenses/mit/
 * @link      http://lorem.ovh
 */
class SqlPentester implements PentesterInterface
{
    /**
     * Create and store reports of actions
     * @var  Reporter
     */
    private $_reporter;

    /**
     * A Guzzle client to do HTTP Requests
     * @var $_guzzle \Guzzle\Service\Client
     */
    private $_guzzle;

    /**
     * @var EntityManager
     */
    private $_em;

    /**
     * Automatically setting up a Reporter
     * SqlPentester constructor.
     *
     * @param MisdGuzzleBundle $guzzle A guzzle client
     */

    // initiation of guzzle
    public function __construct($guzzle, EntityManager $em)
    {
        $this->_guzzle = $guzzle;
        $this->_em = $em;
        $this->_reporter = new Reporter("sqli");
    }

    /**
     * Launches the full pentest process
     * @param TargetInterface $target
     * @return string the report
     */
    public function testAndGetReport(TargetInterface $target)
    {
        $this->test($target);
        return $this->getReport();
    }

    public function test(TargetInterface $target)
    {
        //if target = POST
        // do postGosling
        // else
        // do getGosling
        $this->getGosling($target);
    }

    /**
     * Logs an action of the Pentester
     * @param string $msg This is the message to you hou hou
     * @return void
     */
    public function report($msg)
    {
        $this->_reporter->report($msg);
    }

    /**
     * Return the full report
     * @return \AppBundle\Utils\Reporter\Report[]
     */
    public function getReport()
    {
        // TODO: Implement getReport() method.
        return $this->_reporter->getReports();
    }

    // this function replace the undefined parameters from target with sql strings from DB
    public function changeParamsToHackParams(TargetInterface $target, SqlError $sql_error)
    {
        // getting the parameters we need from $target
        $values = $target->getParameters();

        // checking if the parameters are defined or null
        foreach ($values as &$value){
            if (is_null($value)) {
                // providing sql string if null
                $value = $sql_error->getValue();
            }
        }
        // return the new parameters to check
        return $values;
    }

    /**
     * Function doing an sql injection on GET with Guzzle
     * @param SqlTarget $target
     */
    public function getGosling(TargetInterface $target)
    {
        //defining $url and $params from $target
        //setting success to false by default
        $url = $target->getUrl();
        $params = $target->getParameters();
        $success = false;

        $repo = $this->_em->getRepository('AppBundle:SqlError');
        $sql_error = $repo->getSqlError();

        $params = $this->changeParamsToHackParams($target, $sql_error);

        $req = $this->_guzzle->createRequest('GET', $url, $params);

        $success = $this->goslingResponse($req);
        $used_sql_error = $sql_error->getValue();

        // converting a booleen into a string for the report
        if ($success == true){
            $success = "success";
        }else{
            $success = "fail";
        }

        $this->report("sql error status : ".$success."for url ".$url."and slq injection : ".$used_sql_error);

        // checking if the report has the right informations
        dump("sql error status : ".$success." for url ".$url." and slq injection : ".$used_sql_error);

    }

/*    public function postGosling(SqlTarget $target)
    {

        $url     = $target->getUrl();
        $params  = $target->getParameters();
        $success = false;

        $req = $this->_guzzle->createRequest('POST', $url, ['form_params' => $params]);

        $success = $this->goslingResponse($req);

        $this->report("sql error status : "  . $success . "for url ". $url. "and params ". $params);
    }*/

    // function saying according to the status code if the injection was a success or not
    public function goslingResponse(RequestInterface $req)
    {
        $res = $req->send();
        //checking the status code
        echo $res->getStatusCode();

        $status_code = $res->getStatusCode();

        if ( $status_code == 200 ) {
            //do this
            // check if we have certain string in the page by parsing it
            //$parsed =  curl page

            // Create DOM from URL or file
            //request get body -> Ã  voir dans doc de guzzle
            $html = file_get_html($url);

            if ("mysql error")
            {
                //return $result= array{ success => booleen
                //                       stasus_code => $statue_code
                //  }

               $success = true;
            }

            $success = false;
        }

        return $result;
    }
}

