<?php
/**
 * File SqlPentester.php
 *
 * PHP Version 5.6
 *
 * @category  Class
 * @package   Zerowing
 * @author    mrgn <xyz@example.com>
 * @copyright 2016 mrgn
 * @license   MIT http://choosealicense.com/licenses/mit/
 * @link      http://lorem.ovh
 */

namespace AppBundle\Utils\Pentester;

use AppBundle\Entity\SqlError;
use AppBundle\Utils\Reporter\Reporter;
use AppBundle\Utils\Target\SqlTarget;
use AppBundle\Utils\Target\TargetInterface;
use Doctrine\ORM\EntityManager;
use Guzzle\Http\Client;
use Guzzle\Http\Message\RequestInterface;
use Misd\GuzzleBundle\MisdGuzzleBundle;

/**
 * Class SqlPentester
 * @category  Class
 * @package AppBundle\Utils\Pentester
 * @author    mrgn <xyz@example.com>
 * @copyright 2016 mrgn
 * @license   MIT http://choosealicense.com/licenses/mit/
 * @link      http://lorem.ovh
 */
class SqlPentester extends AbstractPentester
{
    /**
     * Create and store reports of actions
     * @var  Reporter
     */
    protected $_reporter;

    /**
     * A Guzzle client to do HTTP Requests
     * @var \Guzzle\Service\Client
     */
    protected $_guzzle;

    /**
     * @var EntityManager
     */
    private $_em;

    /**
     * Automatically setting up a Reporter
     * SqlPentester constructor.
     *
     * @param MisdGuzzleBundle $guzzle A guzzle client
     * @param EntityManager $em
     */
    public function __construct($guzzle, EntityManager $em)
    {
        $this->_guzzle = $guzzle;
        $this->_em = $em;
        parent::__construct($guzzle);
        $this->_reporter = new Reporter("sqli");
    }

    /**
     * Launches the full pentest process
     * @param TargetInterface $target
     * @return string the report
     */
    public function testAndGetReport(TargetInterface $target)
    {
        $this->test($target);

        return $this->getReport();
    }

    /**
     * @inheritdoc
     */
    public function test(TargetInterface $target)
    {
        $this->getGosling($target);
    }

    /**
     * Function doing an sql injection on GET with Guzzle
     * @param SqlTarget $target
     */
    public function getGosling(TargetInterface $target)
    {
        //defining $url and $params from $target
        //setting success to false by default
        $url = $target->getUrl();

        $repo = $this->_em->getRepository('AppBundle:SqlError');
        $sql_error = $repo->getSqlError();

        $params = $this->changeParamsToHackParams($target, $sql_error);

        $req = $this->_guzzle->createRequest('GET', $url, $params);

        $result = $this->goslingResponse($req, $url);
        $used_sql_error = $sql_error->getValue();

        $success = $result["Success"];

        $this->report($success, "for url ".$url."and slq injection : ".$used_sql_error);
    }

    /**
     * This function replace the undefined parameters from target with sql strings from DB
     * @param SqlTarget|TargetInterface $target
     * @param SqlError $sql_error
     * @return array|mixed
     */
    public function changeParamsToHackParams(TargetInterface $target, SqlError $sql_error)
    {
        // getting the parameters we need from $target
        $values = $target->getParameters();

        // checking if the parameters are defined or null
        foreach ($values as &$value) {
            if (is_null($value)) {
                // providing sql string if null
                $value = $sql_error->getValue();
            }
        }

        // return the new parameters to check
        return $values;
    }

    /**
     * Function saying according to the status code if the injection was a success or not
     * @param RequestInterface $req
     * @param $url
     * @return array
     * @internal param SqlTarget $target
     */
    public function goslingResponse(RequestInterface $req, $url)
    {
        $success = false;

        $res = $req->send();

        $status_code = $res->getStatusCode();

        if ($status_code == 200) {

            // Create a request that has a query string and an X-Foo header
            $request = $this->_guzzle->get($url);

            // Send the request and get the response
            $response = $request->send();

            // Connection to DB
            $repo = $this->_em->getRepository('AppBundle:HtmlError');
            $html_errors = $repo->findAll();

            foreach ($html_errors as $html_error) {
                if (preg_match($html_error->getValue(), $response->getBody(true))) {
                    $success = true;
                }
            }
        }

        $result = array(
            "Success" => $success,
            "Status_code" => $status_code,
        );

        return $result;
    }

    /**
     * @inheritdoc
     */
    public function guzzleOverwrite(Client $guzzle)
    {
        $this->_guzzle = $guzzle;
    }
}
