<?php
/**
 * File CurlingPentester.php
 *
 * PHP Version 5.6
 *
 * @category  Class
 * @package   zerowing
 * @author    mrgn <xyz@example.com>
 * @copyright 2016 mrgn
 * @license   MIT http://choosealicense.com/licenses/mit/
 * @link      http://lorem.ovh
 */

use AppBundle\Utils\Reporter\Reporter;
use AppBundle\Utils\Target;
use Misd\GuzzleBundle\MisdGuzzleBundle;

class CurlingPentester
{

    /**
     * A Guzzle client to do HTTP Requests
     * @var $_guzzle \Guzzle\Service\Client
     */
    private $_guzzle;

    /**
     * Automatically setting up a Reporter
     * SqlPentester constructor.
     *
     * @param MisdGuzzleBundle $guzzle A guzzle client
     */
    public function __construct($guzzle)
    {
        $this->_guzzle = $guzzle;
        $this->_reporter = new Reporter("sqli");
    }

    /**
     * @param Target\SqlTarget $target
     *
     *
     * array(
     *  "user" => "admin"
     *  "password" => null
     * )
     */

    /**
     * @param Target\SqlTarget $target
     *
     *
     * if ( user  )
     *    alors faire cette requete
     * if (user == admin )
     *    alors faire une autre requete
     *
     */

    public function doCurling(Target\SqlTarget $target)
    {
        $url = $target->getUrl();
        $params = $target->getParameters();


        // BUT : créer une erreur
        //       trouve une faille à foutre dans 'password'

        // tant que la faille a pas réussi ET j'ai des failles en rab
        //      $newParmas = createParams($params)
        //      faire "tester faille" ($url, $newParams)
        //

    }

    private function createParams($params) {


        /**
         *  array(
         *      "user" => "admin"
         *       "password" => null
         */

        // regarder dans mon tableau si j'ai "null"
        // là ou j'ai null, mettre une hackValue

        /**
         *
         *  array(
         *      "user" => "admin"
         *       "password" => "'"
         * )
         */
        $paramsWithHackValue = null;
        return $paramsWithHackValue;
    }

    private function testFaille($url, $params) {
        //fait la requête curl avec le foreach pour construire l'URL
        //répond oui ou non

        $request = $this->_guzzle->createRequest('GET', 'http://google.com', [
            'query' => ['q' => 'lol']
        ]);

        $result = $request->send();

        dump($result);
    }

    private function hackValue() {
        // regarde mon entité HackValue
        // trouve une faille que j'ai pas encore utilisée
        // renvoie une faille possible
        return "valeur qui crée une erreur";
    }

}
